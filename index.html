<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Аудиовизуализация с AudioWorklet</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        .chart-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }
        canvas {
            max-width: 100%;
            height: 400px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button id="startButton">Начать</button>
        <button id="stopButton" disabled>Остановить</button>
    </div>
    
    <div class="chart-container">
        <canvas id="timeDomainChart" width="800" height="400"></canvas>
        <canvas id="frequencyDomainChart" width="800" height="400"></canvas>
        <canvas id="pitchDomainChart" width="800" height="400"></canvas>
    </div>

    <div class="pitch-display">
        <div id="currentNote" class="note-display"></div>
    </div>

    <style>
        .note-display {
            font-size: 32px;
            text-align: center;
            margin: 10px 0;
        }
    </style>

    <script>
        //Chart.register(ChartAnnotation);
        //
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        
        // Инициализация графиков
        const timeCtx = document.getElementById('timeDomainChart').getContext('2d');
        const freqCtx = document.getElementById('frequencyDomainChart').getContext('2d');
        const pitchCtx = document.getElementById('pitchDomainChart').getContext('2d');
        
        let audioContext;
        let visualizerNode;
        let frequencyAnalyser;
        let freqDataArray;
        let updateInterval;
        let timeChart;
        let freqChart;
        let pitchChart;

        const MAX_FREQ_TO_DISPLAY = 20000;
        const MAX_PITHCES_TO_DISPLAY = 50;

        // Конфигурация графиков
        const timeChartConfig = {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Временная область',
                    data: [],
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 1,
                    fill: false,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Время (отсчеты)'
                        }
                    },
                    y: {
                        // min: -1,
                        // max: 1,
                        title: {
                            display: true,
                            text: 'Амплитуда'
                        }
                    }
                },
                animation: {
                    duration: 0
                }
            }
        };

        const freqChartConfig = {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{
                    label: 'Частотный спектр',
                    data: [],
                    backgroundColor: 'rgba(54, 162, 235, 0.5)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    // borderWidth: 3,
                    // pointRadius: 3
                }]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        display: true,
                        min: 100,
                        max: MAX_FREQ_TO_DISPLAY,
                        title: {
                            display: true,
                            text: 'Частота (Гц)'
                        },
                        type: 'logarithmic'
                    },
                    y: {
                        min: 0,
                        max: 255,
                        title: {
                            display: true,
                            text: 'Мощность'
                        }
                    }
                },
                animation: {
                    duration: 0
                }
            }
        };

        const pitchChartConfig = {
            type: 'line',
            data: {
                datasets: [{
                label: 'Основной тон (Hz)',
                borderColor: 'rgb(255, 99, 132)',
                data: []
                }]
            },
            options: {
                scales: {
                y: {
                    // min: 50,
                    // max: 1000,
                    title: { 
                        display: true,
                        text: 'Частота (Гц)' }
                },
                x: {
                    min: 0,
                    max: MAX_PITHCES_TO_DISPLAY,
                    title: { 
                        display: true,
                        text: 'Время' }
                }
                }, 
                plugins: {
                    annotation: {
                        annotations: {
                            highThreshold: {
                                type: 'line',
                                yMin: 0,    // Значение Y для выделения
                                yMax: 0,
                                borderColor: 'green',
                                borderWidth: 3,
                                borderDash: [6, 6],
                                label: {
                                    display: true,
                                    content: 'Зона тона',
                                    position: 'end',
                                    backgroundColor: 'rgba(255,0,0,0.5)'
                                }
                            },
                            lowThreshold: {
                                type: 'line',
                                yMin: 0,    // Значение Y для выделения
                                yMax: 0,
                                borderColor: 'green',
                                borderWidth: 3,
                                borderDash: [6, 6],
                                label: {
                                    display: true,
                                    content: 'Зона тона',
                                    position: 'end',
                                    backgroundColor: 'rgba(255,0,0,0.5)'
                                }
                            },
                            // dynamicLine: {
                            //     type: 'line',
                            //     yMin: () => calculateThreshold_min(), // Функция вычисляющая значение
                            //     yMax: () => calculateThreshold_max(),
                            //     borderColor: 'purple'
                            // }
                        }
                    }
                }
            }
        };

        // Переменная для хранения всех сэмплов
        let allSamples = [];
        //const CHUNK_SIZE = 512;
        const MAX_SAMPLES = 1024;
        let cnt = 0;

        // Новый метод для загрузки аудиопроцессора
        async function initAudioWorklet() {
            try {
                // Создаем AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Регистрируем процессор
                await audioContext.audioWorklet.addModule('audio-processor.js');
                console.log('AudioWorklet processor успешно загружен');
                return true;
            } catch (error) {
                console.error('Ошибка загрузки AudioWorklet:', error);
                return false;
            }
        }

                // Новый метод для загрузки аудиопроцессора
        async function initPitchWorklet() {
            try {
                // Регистрируем процессор
                //audioContext = new (window.AudioContext || window.webkitAudioContext)();
                await audioContext.audioWorklet.addModule('pitch-processor.js');
                console.log('PitchWorklet processor успешно загружен');
                return true;
            } catch (error) {
                console.error('Ошибка загрузки PitchWorklet:', error);
                return false;
            }
        }

        // Инициализация графиков
        timeChart = new Chart(timeCtx, timeChartConfig);
        freqChart = new Chart(freqCtx, freqChartConfig);
        pitchChart = new Chart(pitchCtx, pitchChartConfig);
        let k=0;

        function updatePitchChart(currentPitch, prev_freq, next_freq, freq_plus30c, freq_minus30c) {
            //const note = frequencyToNote(currentPitch);
            //document.getElementById('currentNote').textContent = note;
            //console.log(currentPitch);
            if (currentPitch == 0)
                return;
            pitchChart.data.datasets[0].data.push(currentPitch);
            pitchChart.data.labels.push(k);
            k++;

            if (pitchChart.data.labels.length >MAX_PITHCES_TO_DISPLAY){
                pitchChart.data.labels.shift();
                pitchChart.data.datasets[0].data.shift();  
                pitchChart.config.options.scales.x.max = k;
            }

            if ((prev_freq!=0) && (next_freq!=0)){
                pitchChart.config.options.scales.y.max = next_freq;
                pitchChart.config.options.scales.y.min = prev_freq; 
                pitchChart.config.options.plugins.annotation.annotations.lowThreshold.yMin = freq_minus30c; 
                pitchChart.config.options.plugins.annotation.annotations.lowThreshold.yMax = freq_minus30c; 
                pitchChart.config.options.plugins.annotation.annotations.highThreshold.yMin = freq_plus30c; 
                pitchChart.config.options.plugins.annotation.annotations.highThreshold.yMax = freq_plus30c;  
            }
            pitchChart.update('none');
        }

        // function frequencyToNote(freq) {
        //     const A4 = 440;
        //     const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        //     const n = Math.round(12 * Math.log2(freq / A4)) + 57;
        //     return notes[n % 12] + Math.floor(n/12);
        // }

        startButton.addEventListener('click', async () => {
            try {
                // Инициализируем AudioWorklet
                workletReady = await initAudioWorklet();
                if (!workletReady) {
                    throw new Error('Не удалось загрузить AudioWorklet');
                }
                workletReady = await initPitchWorklet();
                if (!workletReady) {
                    throw new Error('Не удалось загрузить AudioWorklet');
                }
                
                // Получаем доступ к микрофону
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {        
                        echoCancellation: false,
                        noiseSuppression: false, //true
                        autoGainControl: false,  // Самое важное!
                        latency: 0.01  // Минимальная задержка //true 
                    }
                });
                
                // Создаем узлы обработки
                visualizerNode = new AudioWorkletNode(audioContext, 'audio-visualizer-processor');
                pitchProcessor = new AudioWorkletNode(audioContext, 'pitch-processor');
                frequencyAnalyser = audioContext.createAnalyser();
                frequencyAnalyser.smoothingTimeConstant = 0.1;

                frequencyAnalyser.fftSize = 512; //512
                const freqDataArray = new Uint8Array(frequencyAnalyser.frequencyBinCount);
                const sampleRate = audioContext.sampleRate;

                const totalBins = frequencyAnalyser.frequencyBinCount;
                const binsToShow = Math.floor((MAX_FREQ_TO_DISPLAY / (sampleRate / 2)) * totalBins);

                const freqLabels = Array.from(
                    { length: binsToShow },
                    (_, i) => Math.round(i * sampleRate / (2 * totalBins))
                );
                freqChart.data.labels = freqLabels;
                
                // Подключаем узлы
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(visualizerNode);
                source.connect(frequencyAnalyser);
                source.connect(pitchProcessor);
                pitchProcessor.connect(audioContext.destination);

                pitchProcessor.port.onmessage = (event) => {
                    if (event.data.type === 'pitch') {
                        updatePitchChart(event.data.note_frequency,
                                        event.data.prev_note_frequency, 
                                        event.data.next_note_frequency,
                                        event.data.note_frequency_plus30c,
                                        event.data.note_frequency_minus30c );
                        console.log(event.data.note_name);
                        //console.log(event.data.frequency);
                    }
                };
                
                // Настройка обработки данных
                visualizerNode.port.onmessage = (event) => {
                    if (event.data.decsamples) {
                        //Добавляем новые сэмплы
                        allSamples = [...allSamples, ...event.data.decsamples];
                        
                        // Если превысили максимальное количество - обрезаем начало
                        if (allSamples.length > MAX_SAMPLES) {
                            const removeCount = allSamples.length - MAX_SAMPLES;
                            allSamples = allSamples.slice(removeCount);
                        }
                        
                        // Обновляем график
                        timeChart.data.datasets[0].data = allSamples;
                        timeChart.data.labels = allSamples.map((_, i) => i);
                        //console.log("new data!");

                        cnt++;
                        if (cnt == 2){
                            timeChart.update();
                            frequencyAnalyser.getByteFrequencyData(freqDataArray);
                            freqChart.data.datasets[0].data = Array.from(freqDataArray.slice(0, binsToShow));
                            freqChart.update();                            
                            cnt=0;
                        }
                        
                    }
                };
                
                
                startButton.disabled = true;
                stopButton.disabled = false;
                
            } catch (error) {
                console.error('Ошибка:', error);
                alert('Ошибка: ' + error.message);
            }
        });

        stopButton.addEventListener('click', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            // Очищаем данные
            allSamples = [];
            startButton.disabled = false;
            stopButton.disabled = true;
        });
    </script>
</body>
</html>