<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Аудиовизуализация с AudioWorklet</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        .chart-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }
        canvas {
            max-width: 100%;
            height: 400px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button id="startButton">Начать</button>
        <button id="stopButton" disabled>Остановить</button>
    </div>
    
    <div class="chart-container">
        <canvas id="timeDomainChart" width="800" height="400"></canvas>
        <canvas id="frequencyDomainChart" width="800" height="400"></canvas>
        <canvas id="pitchDomainChart" width="800" height="400"></canvas>
    </div>

    <div class="pitch-display">
        <div id="currentNote" class="note-display"></div>
    </div>

    <style>
        .note-display {
            font-size: 32px;
            text-align: center;
            margin: 10px 0;
        }
    </style>

    <script>
        //Chart.register(ChartAnnotation);
        //
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        
        // Инициализация графиков
        const timeCtx = document.getElementById('timeDomainChart').getContext('2d');
        const freqCtx = document.getElementById('frequencyDomainChart').getContext('2d');
        const pitchCtx = document.getElementById('pitchDomainChart').getContext('2d');
        
        let audioContext;
        let visualizerNode;
        let frequencyAnalyser;
        let freqDataArray;
        let updateInterval;
        let timeChart;
        let freqChart;
        let pitchChart;

        const MAX_FREQ_TO_DISPLAY = 20000;
        const MAX_PITHCES_TO_DISPLAY = 50;
        const VIBRATO_RMS_TRESHOLD = 0.002;
        const VIBRATO_SAMPLE_RATE = 22;

        // Конфигурация графиков
        const timeChartConfig = {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Временная область',
                    data: [],
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 1,
                    fill: false,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Время (отсчеты)'
                        }
                    },
                    y: {
                        // min: -1,
                        // max: 1,
                        title: {
                            display: true,
                            text: 'Амплитуда'
                        }
                    }
                },
                animation: {
                    duration: 0
                }
            }
        };

        const freqChartConfig = {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Частотный спектр',
                    data: [],
                    backgroundColor: 'rgba(54, 162, 235, 0.5)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    fill: true,
                    // barPercentage: 1.0, // Столбцы занимают всю ширину интервала
                    // categoryPercentage: 1.0, // Максимальная ширина
                    // // shadowOffsetX: 2,
                    // // shadowOffsetY: 2,
                    // // shadowBlur: 5,
                    // // shadowColor: 'rgba(0, 0, 0, 0.3)'
                    borderWidth: 0,
                    // //borderColor: 'rgba(0, 0, 0, 1)',
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        display: true,
                        min: 50,
                        max: MAX_FREQ_TO_DISPLAY,
                        title: {
                            display: true,
                            text: 'Частота (Гц)'
                        },
                        type: 'logarithmic'
                    },
                    y: {
                        min: 0,
                        max: 255,
                        title: {
                            display: true,
                            text: 'Мощность'
                        }
                    }
                },
                animation: {
                    duration: 0
                }
            }
        };

        const pitchChartConfig = {
            type: 'line',
            data: {
                datasets: [{
                label: 'Основной тон (Hz)',
                borderColor: 'rgb(255, 99, 132)',
                data: []
                }]
            },
            options: {
                scales: {
                y: {
                    // min: 50,
                    // max: 1000,
                    title: { 
                        display: true,
                        text: 'Частота (Гц)' }
                },
                x: {
                    min: 0,
                    max: MAX_PITHCES_TO_DISPLAY,
                    title: { 
                        display: true,
                        text: 'Время' }
                }
                }, 
                plugins: {
                    annotation: {
                        annotations: {
                            highThreshold: {
                                type: 'line',
                                yMin: 0,    // Значение Y для выделения
                                yMax: 0,
                                borderColor: 'green',
                                borderWidth: 3,
                                borderDash: [6, 6],
                                label: {
                                    display: true,
                                    content: 'Зона тона',
                                    position: 'end',
                                    backgroundColor: 'rgba(255,0,0,0.5)'
                                }
                            },
                            lowThreshold: {
                                type: 'line',
                                yMin: 0,    // Значение Y для выделения
                                yMax: 0,
                                borderColor: 'green',
                                borderWidth: 3,
                                borderDash: [6, 6],
                                label: {
                                    display: true,
                                    content: 'Вибрато',
                                    position: 'end',
                                    backgroundColor: 'rgba(255,0,0,0.5)'
                                }
                            },
                            // dynamicLine: {
                            //     type: 'line',
                            //     yMin: () => calculateThreshold_min(), // Функция вычисляющая значение
                            //     yMax: () => calculateThreshold_max(),
                            //     borderColor: 'purple'
                            // }
                        }
                    }
                }
            }
        };

        // Переменная для хранения всех сэмплов
        let allSamples = [];
        //const CHUNK_SIZE = 512;
        const MAX_SAMPLES = 1024;
        let cnt = 0;

        // Новый метод для загрузки аудиопроцессора
        async function initAudioWorklet() {
            try {
                // Создаем AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Регистрируем процессор
                await audioContext.audioWorklet.addModule('audio-processor.js');
                console.log('AudioWorklet processor успешно загружен');
                return true;
            } catch (error) {
                console.error('Ошибка загрузки AudioWorklet:', error);
                return false;
            }
        }

                // Новый метод для загрузки аудиопроцессора
        async function initPitchWorklet() {
            try {
                // Регистрируем процессор
                //audioContext = new (window.AudioContext || window.webkitAudioContext)();
                await audioContext.audioWorklet.addModule('pitch-processor.js');
                console.log('PitchWorklet processor успешно загружен');
                return true;
            } catch (error) {
                console.error('Ошибка загрузки PitchWorklet:', error);
                return false;
            }
        }

        // Инициализация графиков
        timeChart = new Chart(timeCtx, timeChartConfig);
        freqChart = new Chart(freqCtx, freqChartConfig);
        pitchChart = new Chart(pitchCtx, pitchChartConfig);
        function getVibratoFreq() {
            const PITCH_RATE = 21.5; // Частота обновления высоты тона (Гц)
            const VIBRATO_STDDEV_THRESHOLD = 0.002;
            const SIZE = pitchChart.data.datasets[0].data.length;
            const data = pitchChart.data.datasets[0].data;
            
            // 1. Проверка амплитуды вибрато
            const mean = data.reduce((sum, val) => sum + val, 0) / SIZE;
            const stdDev = Math.sqrt(data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / SIZE);
            
            if (stdDev < VIBRATO_STDDEV_THRESHOLD) {
                return 0; // Слишком малое отклонение
            }

            // 2. Вычисление ACF с нормализацией
            const c = new Array(SIZE).fill(0);
            
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE - i; j++) {
                    c[i] += (data[j] - mean) * (data[j + i] - mean);
                }
                // Нормализация
                c[i] /= (SIZE - i);
            }

            // 3. Поиск пика в диапазоне вибрато (4-8 Гц)
            const MIN_PERIOD = Math.floor(PITCH_RATE / 8); // 8 Гц -> 3 отсчетa
            const MAX_PERIOD = Math.ceil(PITCH_RATE / 4);  // 4 Гц -> 5 отсчетов
            
            let maxVal = -Infinity;
            let maxPos = MIN_PERIOD;
            
            for (let i = MIN_PERIOD; i <= Math.min(MAX_PERIOD, SIZE-1); i++) {
                if (c[i] > maxVal) {
                    maxVal = c[i];
                    maxPos = i;
                }
            }

            // 4. Параболическая интерполяция
            const x1 = c[maxPos - 1];
            const x2 = c[maxPos];
            const x3 = c[maxPos + 1];
            
            const a = (x1 + x3 - 2*x2)/2;
            const b = (x3 - x1)/2;
            
            let T0 = maxPos;
            if (a !== 0) {
                T0 = maxPos - b/(2*a);
            }

            // 5. Проверка значимости пика
            if (maxVal < 0.4 * c[0]) { // Порог корреляции
                return 0;
            }

            return PITCH_RATE / T0;
        }
        // function getVibratoFreq() {
        //     // Implements the ACF2+ algorithm
        //     let SIZE = pitchChart.data.datasets[0].length;
        //     let data = pitchChart.data.datasets[0].data; 
        //     let rms = 0;

        //     for (let i = 0; i < SIZE; i++) {
        //         let val = data[i];
        //         rms += val*val;
        //     }
        //     rms = Math.sqrt(rms/SIZE);
        //     if (rms < VIBRATO_RMS_TRESHOLD) { // not enough signal  
        //         //this.rms = rms;     
        //         return 0;
        //     } 

        //     // let r1 = 0, r2 = SIZE-1, thres = this.THRESHOLD;
        //     // for (let i = 0; i < SIZE/2; i++)
        //     //   if (Math.abs(this.buffer[i]) < thres) { r1 = i; break; }
        //     // for (let i = 1; i < SIZE/2; i++)
        //     //   if (Math.abs(this.buffer[SIZE-i]) < thres) { r2 = SIZE - i; break; }

        //     // this.buffer = this.buffer.slice(r1, r2);
        //     // SIZE = this.buffer.length;

        //     let c = new Array(SIZE).fill(0);
        //     for (let i = 0; i < SIZE; i++)
        //     for (let j = 0; j < SIZE - i; j++)
        //         c[i] = c[i] + data[j]*data[j + i];

        //     let d=0; while (c[d] > c[d + 1]) d++;
        //     let maxval = -1, maxpos = -1;
        //     for (let i = d; i < SIZE; i++) {
        //     if (c[i] > maxval) {
        //         maxval = c[i];
        //         maxpos = i;
        //     }
        //     }
        //     let T0 = maxpos;

        //     let x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
        //     let a = (x1 + x3 - 2*x2)/2;
        //     let b = (x3 - x1)/2;
        //     if (a) T0 = T0 - b/(2*a);

        //     //this.rms = rms;
        //     //this.lastPitch = sampleRate/T0;
        //     return VIBRATO_SAMPLE_RATE/T0;
        
        // }

        let k=0;

        function updatePitchChart(currentPitch, prev_freq, next_freq, freq_plus30c, freq_minus30c, note_name) {
            //const note = frequencyToNote(currentPitch);
            //document.getElementById('currentNote').textContent = note;
            //console.log(currentPitch);
            if (currentPitch == 0)
                return;
            pitchChart.data.datasets[0].data.push(currentPitch);
            pitchChart.data.labels.push(k);
            k++;

            if (pitchChart.data.labels.length >MAX_PITHCES_TO_DISPLAY){
                pitchChart.data.labels.shift();
                pitchChart.data.datasets[0].data.shift();  
                pitchChart.config.options.scales.x.max = k;
            }
            let vibrato_freq = getVibratoFreq();
            vibrato_freq = (Math.round(vibrato_freq*100))/100;
            if ((prev_freq!=0) && (next_freq!=0)){
                pitchChart.config.options.scales.y.max = next_freq;
                pitchChart.config.options.scales.y.min = prev_freq; 
                pitchChart.config.options.plugins.annotation.annotations.lowThreshold.yMin = freq_minus30c; 
                pitchChart.config.options.plugins.annotation.annotations.lowThreshold.yMax = freq_minus30c; 
                pitchChart.config.options.plugins.annotation.annotations.highThreshold.yMin = freq_plus30c; 
                pitchChart.config.options.plugins.annotation.annotations.highThreshold.yMax = freq_plus30c;  
                pitchChart.config.options.plugins.annotation.annotations.highThreshold.label.content = "Зона " + note_name;
                pitchChart.config.options.plugins.annotation.annotations.lowThreshold.label.content = "Вибрато " + vibrato_freq + "Гц";
            }
            
            //console.log(vibrato_freq);
            pitchChart.update('none');
        }

    
        // function frequencyToNote(freq) {
        //     const A4 = 440;
        //     const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        //     const n = Math.round(12 * Math.log2(freq / A4)) + 57;
        //     return notes[n % 12] + Math.floor(n/12);
        // }

        startButton.addEventListener('click', async () => {
            try {
                // Инициализируем AudioWorklet
                workletReady = await initAudioWorklet();
                if (!workletReady) {
                    throw new Error('Не удалось загрузить AudioWorklet');
                }
                workletReady = await initPitchWorklet();
                if (!workletReady) {
                    throw new Error('Не удалось загрузить AudioWorklet');
                }
                
                // Получаем доступ к микрофону
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {        
                        echoCancellation: false,
                        noiseSuppression: false, //true
                        autoGainControl: false,  // Самое важное!
                        latency: 0.01  // Минимальная задержка //true 
                    }
                });
                
                // Создаем узлы обработки
                visualizerNode = new AudioWorkletNode(audioContext, 'audio-visualizer-processor');
                pitchProcessor = new AudioWorkletNode(audioContext, 'pitch-processor');
                frequencyAnalyser = audioContext.createAnalyser();
                frequencyAnalyser.smoothingTimeConstant = 0.1;

                frequencyAnalyser.fftSize = 8192; //512
                const freqDataArray = new Uint8Array(frequencyAnalyser.frequencyBinCount);
                const sampleRate = audioContext.sampleRate;

                const totalBins = frequencyAnalyser.frequencyBinCount;
                const binsToShow = totalBins;//Math.floor((MAX_FREQ_TO_DISPLAY / (sampleRate / 2)) * totalBins);

                const freqLabels = Array.from(
                    { length: binsToShow },
                    (_, i) => Math.round(i * sampleRate / (2 * totalBins))
                );
                freqChart.data.labels = freqLabels;
                
                // Подключаем узлы
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(visualizerNode);
                source.connect(frequencyAnalyser);
                source.connect(pitchProcessor);
                pitchProcessor.connect(audioContext.destination);

                pitchProcessor.port.onmessage = (event) => {
                    if (event.data.type === 'pitch') {
                        updatePitchChart(event.data.note_frequency,
                                        event.data.prev_note_frequency, 
                                        event.data.next_note_frequency,
                                        event.data.note_frequency_plus30c,
                                        event.data.note_frequency_minus30c,
                                        event.data.note_name );
                        console.log(event.data.note_name);
                        //console.log(event.data.frequency);
                    }
                };
                
                // Настройка обработки данных
                visualizerNode.port.onmessage = (event) => {
                    if (event.data.decsamples) {
                        //Добавляем новые сэмплы
                        allSamples = [...allSamples, ...event.data.decsamples];
                        
                        // Если превысили максимальное количество - обрезаем начало
                        if (allSamples.length > MAX_SAMPLES) {
                            const removeCount = allSamples.length - MAX_SAMPLES;
                            allSamples = allSamples.slice(removeCount);
                        }
                        
                        // Обновляем график
                        timeChart.data.datasets[0].data = allSamples;
                        timeChart.data.labels = allSamples.map((_, i) => i);
                        //console.log("new data!");

                        cnt++;
                        if (cnt == 2){
                            timeChart.update();
                            frequencyAnalyser.getByteFrequencyData(freqDataArray);
                            freqChart.data.datasets[0].data = Array.from(freqDataArray.slice(0, binsToShow));
                            freqChart.update();                            
                            cnt=0;
                        }
                        
                    }
                };
                
                
                startButton.disabled = true;
                stopButton.disabled = false;
                
            } catch (error) {
                console.error('Ошибка:', error);
                alert('Ошибка: ' + error.message);
            }
        });

        stopButton.addEventListener('click', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            // Очищаем данные
            allSamples = [];
            startButton.disabled = false;
            stopButton.disabled = true;
        });
    </script>
</body>
</html>